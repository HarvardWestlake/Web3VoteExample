<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Class Voting System</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    .container {
      background-color: #f9f9f9;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 20px;
    }
    .section {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid #eee;
    }
    button {
      background-color: #4CAF50;
      border: none;
      color: white;
      padding: 10px 15px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      font-size: 14px;
      margin: 4px 2px;
      cursor: pointer;
      border-radius: 4px;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    input, textarea, select {
      width: 100%;
      padding: 8px;
      margin: 8px 0;
      display: inline-block;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .status {
      font-weight: bold;
      color: #555;
    }
    .proposal {
      background-color: white;
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      border: 1px solid #ddd;
    }
    .active {
      border-left: 4px solid #4CAF50;
    }
    .completed {
      border-left: 4px solid #3498db;
    }
    .cooldown {
      color: #d35400;
      font-weight: bold;
      margin-top: 10px;
      padding: 5px;
      background-color: #fff3e0;
      border-radius: 4px;
    }
    
    #ownerTransferSection {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px dashed #ccc;
    }
    
    .vote-options {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin: 10px 0;
    }
    
    .vote-option {
      display: flex;
      align-items: center;
      padding: 5px;
      border-radius: 4px;
      background-color: #f5f5f5;
    }
    
    .vote-option-label {
      min-width: 100px;
      font-weight: bold;
    }
    
    .vote-bar {
      height: 20px;
      background-color: #4CAF50;
      border-radius: 2px;
      min-width: 5px;
      margin-right: 5px;
    }
    
    .winner {
      color: #4CAF50;
      font-weight: bold;
    }
    
    .check-winner-btn {
      background-color: #3498db;
      margin-top: 5px;
    }
    
    /* GIF Gallery Styles */
    .gif-gallery {
      display: flex;
      justify-content: space-around;
      flex-wrap: wrap;
      margin-top: 20px;
      gap: 15px;
    }
    
    .gif-container {
      width: 30%;
      min-width: 300px;
      border: 1px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      background-color: white;
      text-align: center;
    }
    
    .gif-container img {
      width: 100%;
      height: 200px;
      object-fit: cover;
      display: block;
    }
    
    .gif-title {
      padding: 10px;
      font-weight: bold;
      background-color: #f5f5f5;
      border-top: 1px solid #eee;
    }
    
    @media (max-width: 768px) {
      .gif-container {
        width: 45%;
      }
    }
    
    @media (max-width: 480px) {
      .gif-container {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <h1>Class Voting System</h1>
  
  <div class="container">
    <div class="section">
      <h2>Connection</h2>
      <p>Status: <span id="status" class="status">Disconnected</span></p>
      <p>Account: <span id="account">Not connected</span></p>
      <p>Role: <span id="role">Unknown</span></p>
      <button id="connectButton">Connect Wallet</button>
    </div>

    <div id="ownerSection" style="display:none" class="section">
      <h2>Instructor Controls</h2>
      
      <div>
        <h3>Create Proposal</h3>
        <textarea id="proposalDescription" rows="4" placeholder="Enter your proposal question (e.g., 'Which homework assignment do you want?'). Options will be numbered 1-10 automatically."></textarea>
        <button id="submitProposalButton">Submit Proposal</button>
      </div>
      
      <div>
        <h3>Manage Voting</h3>
        <select id="proposalSelector">
          <option value="">Select a proposal</option>
        </select>
        <button id="startVotingButton">Start Voting</button>
        <button id="stopVotingButton">Stop Voting</button>
      </div>
      
      <div>
        <h3>Manage Voters</h3>
        <input id="voterAddress" type="text" placeholder="Enter wallet address to whitelist">
        <button id="addVoterButton">Add Voter</button>
        <textarea id="multipleVoters" rows="4" placeholder="Enter multiple addresses (one per line, max 30)"></textarea>
        <button id="addMultipleVotersButton">Add Multiple Voters</button>
      </div>
    </div>

    <div id="voterSection" style="display:none" class="section">
      <h2>Student Voting</h2>
      <div id="activeProposal" class="proposal">
        <p>No active proposal</p>
      </div>
      <div id="voteOptionsContainer" style="display:none">
        <h3>Cast Your Vote:</h3>
        <select id="voteOptionSelect">
          <option value="">Select an option</option>
          <option value="1">Option 1</option>
          <option value="2">Option 2</option>
          <option value="3">Option 3</option>
        </select>
        <button id="voteButton" disabled>Vote</button>
      </div>
    </div>

    <div class="section">
      <h2>Proposals</h2>
      <button id="refreshProposalsButton">Refresh Proposals</button>
      <div id="proposalsList">
        <p>No proposals yet</p>
      </div>
    </div>

    <!-- GIF Gallery Section -->
    <div class="section">
      <h2>Voting Options Illustrated</h2>
      <div class="gif-gallery">
        <div class="gif-container">
          <img src="gifs/1.gif" alt="Option 1">
          <div class="gif-title">Option 1</div>
        </div>
        <div class="gif-container">
          <img src="gifs/2.gif" alt="Option 2">
          <div class="gif-title">Option 2</div>
        </div>
        <div class="gif-container">
          <img src="gifs/3.gif" alt="Option 3">
          <div class="gif-title">Option 3</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Load Latest Ethers.js v6 from CDN -->
  <script src="ethers.min.js" type="application/javascript"></script>
  <script>
    // Contract details
    let contractAddress = "0x36676ec614f9a665b4a809cdf5992b8dbb17b2b6"; // Updated contract address
    const contractOwner = "0xCcD83cb05aAaf714289b226eC437B2Cf0C9f3a89";
    
    // Variables for contract interaction
    let provider, signer, contract;
    let userAddress = null;
    let isOwner = false;
    let abi = null;
    
    // DOM Elements
    const connectButton = document.getElementById('connectButton');
    const statusElement = document.getElementById('status');
    const accountElement = document.getElementById('account');
    const roleElement = document.getElementById('role');
    const ownerSection = document.getElementById('ownerSection');
    const voterSection = document.getElementById('voterSection');
    const proposalDescription = document.getElementById('proposalDescription');
    const submitProposalButton = document.getElementById('submitProposalButton');
    const proposalSelector = document.getElementById('proposalSelector');
    const startVotingButton = document.getElementById('startVotingButton');
    const stopVotingButton = document.getElementById('stopVotingButton');
    const voterAddress = document.getElementById('voterAddress');
    const addVoterButton = document.getElementById('addVoterButton');
    const multipleVoters = document.getElementById('multipleVoters');
    const addMultipleVotersButton = document.getElementById('addMultipleVotersButton');
    const activeProposal = document.getElementById('activeProposal');
    const voteButton = document.getElementById('voteButton');
    const voteOptionSelect = document.getElementById('voteOptionSelect');
    const voteOptionsContainer = document.getElementById('voteOptionsContainer');
    const proposalsList = document.getElementById('proposalsList');
    const refreshProposalsButton = document.getElementById('refreshProposalsButton');
    
    // Load ABI from external file
    async function loadABI() {
      try {
        statusElement.innerText = "Loading contract ABI...";
        
        // First try to fetch with absolute path
        let response;
        try {
          response = await fetch('./contract/abi.json');
          if (!response.ok) {
            throw new Error(`HTTP error! Status: ${response.status}`);
          }
        } catch (fetchError) {
          console.warn("Failed to load ABI from ./contract/abi.json:", fetchError);
          
          // Try alternative path
          try {
            response = await fetch('../contract/abi.json');
            if (!response.ok) {
              throw new Error(`HTTP error with alternative path! Status: ${response.status}`);
            }
          } catch (altFetchError) {
            console.warn("Failed to load ABI from ../contract/abi.json:", altFetchError);
            
            // Last resort: try to load from root
            response = await fetch('/contract/abi.json');
            if (!response.ok) {
              throw new Error(`HTTP error with root path! Status: ${response.status}`);
            }
          }
        }
        
        abi = await response.json();
        console.log("ABI loaded successfully:", abi.length, "entries");
        
        // Verify the ABI has required functions
        const requiredFunctions = ['getActiveProposal', 'vote', 'proposals', 'activeProposalId'];
        const missingFunctions = requiredFunctions.filter(func => 
          !abi.some(entry => entry.name === func)
        );
        
        if (missingFunctions.length > 0) {
          console.warn("Loaded ABI is missing required functions:", missingFunctions);
          statusElement.innerText = `Warning: ABI may be incomplete - missing ${missingFunctions.join(', ')}`;
        } else {
          statusElement.innerText = "Contract ABI loaded successfully";
        }
        
        // Enable connect button once ABI is loaded
        connectButton.disabled = false;
      } catch (error) {
        console.error("Error loading ABI:", error);
        
        // Display a more helpful error message and recovery options
        const errorHTML = `
          <div style="color: red; margin-top: 10px; padding: 10px; border: 1px solid red; background: #fff8f8;">
            <p><strong>Error loading ABI:</strong> ${error.message}</p>
            <p>Please check that:</p>
            <ul>
              <li>You're running this page from a web server (not just opening the HTML file directly)</li>
              <li>The contract/abi.json file is in the correct location</li>
              <li>Your web server has proper CORS settings enabled</li>
            </ul>
          </div>
        `;
        
        document.querySelector('.section:first-of-type').insertAdjacentHTML('beforeend', errorHTML);
        statusElement.innerText = "Error loading ABI file";
      }
    }
    
    // Initialize the page
    async function init() {
      connectButton.disabled = true;
      statusElement.innerText = "Initializing...";
      await loadABI();
    }
    
    // Helper to format votes array into a nice HTML display
    function formatVotesDisplay(votes, proposalId, isActive) {
      let totalVotes = 0;
      for (let i = 0; i < votes.length; i++) {
        totalVotes += parseInt(votes[i].toString());
      }
      
      // Generate basic option list without vote counts initially
      let html = `<div class="vote-options" id="vote-options-${proposalId}">`;
      
      // Only display options 1-3 (indices 0-2)
      const maxOptionsToShow = 3;
      for (let i = 0; i < Math.min(maxOptionsToShow, votes.length); i++) {
        const voteCount = parseInt(votes[i].toString());
        if (voteCount === 0 && totalVotes === 0) continue; // Skip options with 0 votes when no votes cast
        
        const percentage = totalVotes > 0 ? (voteCount / totalVotes) * 100 : 0;
        const width = percentage > 0 ? percentage : 1; // Min 1% width for visibility
        
        // Create option div with results hidden by default
        html += `
          <div class="vote-option">
            <div class="vote-option-label">Option ${i+1}:</div>
            <div class="vote-results" style="display: none;">
              <div class="vote-bar" style="width: ${width}%"></div>
              <div>${voteCount} votes (${percentage.toFixed(1)}%)</div>
            </div>
          </div>
        `;
      }
      
      html += `</div>`;
      
      // Add view results button - initially hidden, will be shown if user has voted
      html += `<button class="view-results-btn" id="view-results-${proposalId}" style="display: none;" onclick="toggleVoteResults(${proposalId})">View Results</button>`;
      
      // Add check winner button for completed proposals
      if (!isActive && totalVotes > 0) {
        html += `<button class="check-winner-btn" onclick="checkWinner(${proposalId})">Check Winner</button>`;
      }
      
      return html;
    }
    
    // Function to toggle vote results visibility
    function toggleVoteResults(proposalId) {
      const resultsElements = document.querySelectorAll(`#vote-options-${proposalId} .vote-results`);
      const button = document.getElementById(`view-results-${proposalId}`);
      
      // Toggle display of results
      let isVisible = false;
      resultsElements.forEach(el => {
        if (el.style.display === 'none') {
          el.style.display = 'flex';
          isVisible = true;
        } else {
          el.style.display = 'none';
          isVisible = false;
        }
      });
      
      // Update button text based on state
      button.textContent = isVisible ? 'Hide Results' : 'View Results';
    }
    
    // Function to check if user has voted and update button visibility
    async function checkUserVoteStatus(proposalId) {
      if (!contract || !userAddress) return;
      
      try {
        // Get the last vote time for the user
        const lastVoteTime = await contract.getLastVoteTime(userAddress);
        const hasVoted = lastVoteTime.toString() !== "0";
        
        // Show view results button only if the user has voted
        const viewResultsBtn = document.getElementById(`view-results-${proposalId}`);
        if (viewResultsBtn) {
          viewResultsBtn.style.display = hasVoted ? 'inline-block' : 'none';
        }
      } catch (error) {
        console.error("Error checking user vote status:", error);
      }
    }
    
    // Make functions available globally
    window.checkWinner = checkWinner;
    window.toggleVoteResults = toggleVoteResults;
    
    // Add event listeners
    connectButton.addEventListener('click', connectWallet);
    submitProposalButton.addEventListener('click', submitProposal);
    startVotingButton.addEventListener('click', startVoting);
    stopVotingButton.addEventListener('click', stopVoting);
    addVoterButton.addEventListener('click', addVoter);
    addMultipleVotersButton.addEventListener('click', addMultipleVoters);
    voteButton.addEventListener('click', vote);
    refreshProposalsButton.addEventListener('click', loadProposals);

    // Connect to wallet
    async function connectWallet() {
      try {
        if (!abi) {
          alert("Contract ABI not loaded. Please refresh the page and try again.");
          return;
        }
        
        // Check if MetaMask is installed
        if (window.ethereum == null) {
          statusElement.innerText = "MetaMask not installed; using read-only defaults";
          // If MetaMask is not installed, we use the default provider
          provider = ethers.getDefaultProvider();
          contract = new ethers.Contract(contractAddress, abi, provider);
        } else {
          // Connect to MetaMask
          provider = new ethers.BrowserProvider(window.ethereum);
          
          // Request account access
          await provider.send("eth_requestAccounts", []);
          
          // Get the signer
          signer = await provider.getSigner();
          userAddress = await signer.getAddress();
          
          // Check the network and display information
          const network = await provider.getNetwork();
          console.log("Connected to network:", network);
          statusElement.innerText = `Connected to ${network.name || 'chain ID ' + network.chainId}`;
          
          // Create contract instance with write access
          try {
            contract = new ethers.Contract(contractAddress, abi, signer);
            console.log("Contract instance created successfully");
          } catch (contractCreateError) {
            console.error("Error creating contract instance:", contractCreateError);
            statusElement.innerText = "Failed to create contract instance";
            alert("Error connecting to contract. Please check your network and contract address.");
            return;
          }
          
          // Verify the contract exists
          try {
            // Try to call a view function to check if contract exists
            statusElement.innerText = "Verifying contract...";
            const code = await provider.getCode(contractAddress);
            console.log(`Contract code at ${contractAddress}:`, code.length > 100 ? code.substring(0, 100) + "..." : code);
            
            if (code === '0x' || code === '0x0') {
              throw new Error("No contract deployed at the specified address. Please check your contract address.");
            }
            
            // Verify ABI compatibility by calling a basic view function
            try {
              const count = await contract.proposalCount();
              console.log("Proposal count:", count.toString());
            } catch (abiError) {
              console.error("ABI compatibility error:", abiError);
              alert("The ABI doesn't seem to match the deployed contract. Check your ABI file.");
              return;
            }
            
            // Check if user is the owner
            const ownerAddress = await contract.owner();
            console.log("Contract owner:", ownerAddress);
            console.log("Current user:", userAddress);
            isOwner = (ownerAddress.toLowerCase() === userAddress.toLowerCase());
            
            // Update UI
            statusElement.innerText = "Connected";
            accountElement.innerText = userAddress;
            roleElement.innerText = isOwner ? "Instructor (Owner)" : "Student";
            
            // Show appropriate sections
            ownerSection.style.display = isOwner ? "block" : "none";
            voterSection.style.display = !isOwner ? "block" : "none";
            
            // Add owner transfer section if owner
            if (isOwner && !document.getElementById('ownerTransferSection')) {
              const ownerTransferHTML = `
                <div>
                  <h3>Transfer Ownership</h3>
                  <input id="newOwnerAddress" type="text" placeholder="Enter new owner address">
                  <button id="transferOwnershipButton">Transfer Ownership</button>
                </div>
              `;
              const div = document.createElement('div');
              div.id = 'ownerTransferSection';
              div.innerHTML = ownerTransferHTML;
              ownerSection.appendChild(div);
              
              // Add event listener for the new button
              document.getElementById('transferOwnershipButton').addEventListener('click', transferOwnership);
            }
            
            // Load proposals
            await loadProposals();
            
            // Check if user is whitelisted for voting
            if (!isOwner) {
              const isWhitelisted = await contract.whitelist(userAddress);
              console.log("User whitelisted:", isWhitelisted);
              
              // Check voting cooldown
              if (isWhitelisted) {
                const lastVoteTime = await contract.getLastVoteTime(userAddress);
                console.log("Last vote time:", lastVoteTime.toString());
                const currentTime = Math.floor(Date.now() / 1000); // Current time in seconds
                const sevenDays = 7 * 24 * 60 * 60; // 7 days in seconds
                
                const canVoteNow = lastVoteTime.toString() === "0" || 
                                  currentTime >= parseInt(lastVoteTime.toString()) + sevenDays;
                
                voteButton.disabled = !canVoteNow;
                
                if (!canVoteNow) {
                  const nextVoteTime = new Date((parseInt(lastVoteTime.toString()) + sevenDays) * 1000);
                  activeProposal.innerHTML += `<p class="cooldown">You can vote again after: ${nextVoteTime.toLocaleString()}</p>`;
                }
              } else {
                voteButton.disabled = true;
                activeProposal.innerHTML = "<p>You are not whitelisted to vote. Please contact your instructor.</p>";
              }
              
              await checkActiveProposal();
            }
          } catch (contractError) {
            console.error("Contract verification error:", contractError);
            statusElement.innerText = "Contract error: " + contractError.message;
            alert("There was an issue with the contract: " + contractError.message);
          }
        }
      } catch (error) {
        console.error("Connection error:", error);
        statusElement.innerText = "Connection failed: " + error.message;
      }
    }
    
    // Transfer ownership (owner only)
    async function transferOwnership() {
      if (!isOwner) {
        alert("Only the current owner can transfer ownership");
        return;
      }
      
      const newOwnerAddress = document.getElementById('newOwnerAddress').value.trim();
      if (!newOwnerAddress || !ethers.isAddress(newOwnerAddress)) {
        alert("Please enter a valid Ethereum address");
        return;
      }
      
      try {
        statusElement.innerText = "Transferring ownership...";
        const tx = await contract.changeOwner(newOwnerAddress);
        await tx.wait();
        statusElement.innerText = "Ownership transferred successfully!";
        alert(`Ownership transferred to ${newOwnerAddress}. You will no longer have owner privileges after page refresh.`);
        document.getElementById('newOwnerAddress').value = "";
      } catch (error) {
        console.error("Error transferring ownership:", error);
        statusElement.innerText = "Error transferring ownership: " + error.message;
      }
    }
    
    // Load all proposals
    async function loadProposals() {
      if (!contract) {
        alert("Please connect your wallet first");
        return;
      }
      
      try {
        // Clear existing proposals first
        proposalsList.innerHTML = "<p>Loading proposals...</p>";
        proposalSelector.innerHTML = "<option value=''>Select a proposal</option>";
        
        // Try to get proposal count with error handling
        let count;
        try {
          count = await contract.proposalCount();
          console.log("Total proposal count:", count.toString());
        } catch (countError) {
          console.error("Error getting proposal count:", countError);
          
          // Handle missing or incorrect contract
          if (countError.message.includes("BAD_DATA") || 
              countError.message.includes("could not decode result data")) {
            proposalsList.innerHTML = "<p>Error: Could not connect to the contract. Please check if:</p>" + 
                                     "<ul>" +
                                     "<li>The contract address is correct</li>" +
                                     "<li>The contract is deployed on the current network</li>" +
                                     "<li>You're connected to the correct network</li>" +
                                     "</ul>";
            statusElement.innerText = "Contract connection error";
            return;
          }
          
          throw countError;
        }
        
        let activeId;
        try {
          activeId = await contract.activeProposalId();
          console.log("Active proposal ID from contract:", activeId.toString());
        } catch (error) {
          console.error("Error getting active proposal ID:", error);
          activeId = 0;
        }
        
        if (count.toString() === "0") {
          proposalsList.innerHTML = "<p>No proposals yet</p>";
          return;
        }
        
        // Loading message while we fetch proposals
        proposalsList.innerHTML = "";
        
        // For non-owners, check if there's an active proposal (including proposal 0)
        if (!isOwner) {
          try {
            console.log("Loading active proposal for non-owner, ID:", activeId.toString());
            
            // Get the proposal and check if it's actually active, regardless of ID
            const proposal = await contract.proposals(activeId);
            console.log("Active proposal data:", proposal);
            
            // Extract proposal data carefully
            let description, votes, isActive;
            
            // Check if the result is an array (old ethers) or an object (ethers v6)
            if (Array.isArray(proposal)) {
              [description, votes, isActive] = proposal;
            } else if (proposal.description !== undefined) {
              // Handle object format
              description = proposal.description;
              votes = proposal.votes;
              isActive = proposal.active;
            } else {
              // Try to destructure the result as a tuple
              description = proposal[0];
              votes = proposal[1];
              isActive = proposal[2];
            }
            
            console.log("Parsed proposal details:", {
              description: description,
              isActive: isActive,
              votes: Array.isArray(votes) ? votes.map(v => v.toString()) : "Not an array"
            });
            
            if (isActive) {
              // Show active proposal for regular users
              const proposalDiv = document.createElement('div');
              proposalDiv.className = `proposal active`;
              proposalDiv.innerHTML = `
                <h3>Current Vote: Proposal #${activeId}</h3>
                <p>${description}</p>
                ${formatVotesDisplay(votes, activeId, true)}
              `;
              proposalsList.appendChild(proposalDiv);
              
              // Check if user has voted to show/hide results button
              await checkUserVoteStatus(activeId);
            } else {
              proposalsList.innerHTML = "<p>No active proposals to vote on at the moment</p>";
            }
          } catch (error) {
            console.error(`Error loading active proposal:`, error);
            proposalsList.innerHTML = `<p>Error loading active proposal: ${error.message}</p>`;
          }
        } 
        // For owners, show all proposals
        else if (isOwner) {
          console.log("Loading all proposals for owner");
          // Load each proposal
          for (let i = 0; i < count; i++) {
            try {
              console.log(`Loading proposal #${i}`);
              const proposal = await contract.proposals(i);
              console.log(`Proposal #${i} data:`, proposal);
              
              // Extract proposal data carefully
              let description, votes, isActive;
              
              // Check if the result is an array (old ethers) or an object (ethers v6)
              if (Array.isArray(proposal)) {
                [description, votes, isActive] = proposal;
              } else if (proposal.description !== undefined) {
                // Handle object format
                description = proposal.description;
                votes = proposal.votes;
                isActive = proposal.active;
              } else {
                // Try to destructure the result as a tuple
                description = proposal[0];
                votes = proposal[1];
                isActive = proposal[2];
              }
              
              // Add to proposals list
              const proposalDiv = document.createElement('div');
              proposalDiv.className = `proposal ${isActive ? 'active' : 'completed'}`;
              proposalDiv.innerHTML = `
                <h3>Proposal #${i}</h3>
                <p>${description}</p>
                ${formatVotesDisplay(votes, i, isActive)}
                <p>Status: ${isActive ? 'Active' : 'Inactive'}</p>
              `;
              proposalsList.appendChild(proposalDiv);
              
              // Add to selector dropdown (for owner)
              const option = document.createElement('option');
              option.value = i;
              option.textContent = `Proposal #${i}: ${description.substring(0, 30)}${description.length > 30 ? '...' : ''}`;
              if (isActive) {
                option.textContent += " (Active)";
              }
              proposalSelector.appendChild(option);
            } catch (error) {
              console.error(`Error loading proposal ${i}:`, error);
              const proposalDiv = document.createElement('div');
              proposalDiv.className = 'proposal';
              proposalDiv.innerHTML = `<h3>Proposal #${i}</h3><p>Error loading proposal details: ${error.message}</p>`;
              proposalsList.appendChild(proposalDiv);
            }
          }
        } else {
          // No active proposals for non-owners
          proposalsList.innerHTML = "<p>No active proposals to vote on at the moment</p>";
        }
        
        // Check active proposal for voters
        if (!isOwner) {
          await checkActiveProposal();
        }
      } catch (error) {
        console.error("Error loading proposals:", error);
        proposalsList.innerHTML = `<p>Error loading proposals: ${error.message}</p>`;
        statusElement.innerText = `Error: ${error.message}`;
      }
    }
    
    // Check winner for a proposal
    async function checkWinner(proposalId) {
      try {
        statusElement.innerText = "Checking winner...";
        const [winningOption, voteCount] = await contract.checkWinnerForProposal(proposalId);
        
        // Find the proposal div to update
        const proposals = document.querySelectorAll('.proposal');
        for (let i = 0; i < proposals.length; i++) {
          const heading = proposals[i].querySelector('h3');
          if (heading && heading.textContent.includes(`Proposal #${proposalId}`)) {
            // Find all vote option divs
            const voteOptions = proposals[i].querySelectorAll('.vote-option');
            
            // Remove any existing winner classes
            voteOptions.forEach(option => {
              option.classList.remove('winner');
            });
            
            // Add winner class to the winning option if it exists
            if (winningOption > 0 && voteOptions.length >= winningOption) {
              voteOptions[winningOption-1].classList.add('winner');
              voteOptions[winningOption-1].innerHTML += ` <span class="winner">WINNER! (${voteCount} votes)</span>`;
            }
            
            break;
          }
        }
        
        statusElement.innerText = `Winner checked: Option ${winningOption} with ${voteCount} votes`;
      } catch (error) {
        console.error("Error checking winner:", error);
        statusElement.innerText = "Error checking winner: " + error.message;
      }
    }
    
    // Check active proposal
    async function checkActiveProposal() {
      try {
        // Add debug information to the UI to help troubleshoot
        statusElement.innerText = "Checking active proposal...";
        
        const activeId = await contract.activeProposalId();
        console.log("Active proposal ID:", activeId.toString());
        
        // Instead of checking if activeId is 0, check if the proposal exists and is active
        // First, check if there are any proposals
        const proposalCount = await contract.proposalCount();
        if (proposalCount.toString() === "0") {
          console.log("No proposals exist yet");
          activeProposal.innerHTML = "<p>No proposals have been created yet</p>";
          voteOptionsContainer.style.display = "none";
          voteButton.disabled = true;
          return;
        }
        
        // Now check if the active proposal exists and is actually active
        try {
          console.log("Calling getActiveProposal()");
          const rawResult = await contract.getActiveProposal();
          console.log("getActiveProposal raw result:", rawResult);
          
          // Use the helper function to decode
          const result = decodeActiveProposal(rawResult);
          console.log("Decoded active proposal:", result);
          
          if (!result.isActive) {
            console.log("Proposal marked as inactive");
            activeProposal.innerHTML = "<p>No active proposal at the moment</p>";
            voteOptionsContainer.style.display = "none";
            voteButton.disabled = true;
            return;
          }
          
          // Update UI with proposal details
          activeProposal.innerHTML = `
            <h3>Current Vote:</h3>
            <p>${result.description}</p>
            ${formatVotesDisplay(result.votes, activeId, true)}
          `;
          
          // Check if user has voted to show/hide results button
          await checkUserVoteStatus(activeId);
          
          // Update vote options dropdown based on the proposal
          updateVoteOptions(result.description);
          
          // Show voting options
          voteOptionsContainer.style.display = "block";
        } catch (innerError) {
          console.error("Error getting active proposal details:", innerError);
          
          // Try alternative approach: directly fetch the proposal
          try {
            console.log("Trying alternative approach to get active proposal...");
            const proposal = await contract.proposals(activeId);
            console.log("Direct proposal data:", proposal);
            
            let description, votes, isActive;
            
            // Extract the data
            if (Array.isArray(proposal)) {
              [description, votes, isActive] = proposal;
            } else if (proposal.description !== undefined) {
              description = proposal.description;
              votes = proposal.votes;
              isActive = proposal.active;
            } else {
              description = proposal[0];
              votes = proposal[1];
              isActive = proposal[2];
            }
            
            if (isActive) {
              activeProposal.innerHTML = `
                <h3>Current Vote:</h3>
                <p>${description}</p>
                ${formatVotesDisplay(votes, activeId, true)}
              `;
              
              updateVoteOptions(description);
              voteOptionsContainer.style.display = "block";
            } else {
              activeProposal.innerHTML = "<p>No active proposal at the moment</p>";
              voteOptionsContainer.style.display = "none";
              voteButton.disabled = true;
            }
          } catch (fallbackError) {
            console.error("Both methods failed to get active proposal:", fallbackError);
            activeProposal.innerHTML = `<p>Error retrieving proposal details: ${innerError.message}</p>`;
            voteOptionsContainer.style.display = "none";
            voteButton.disabled = true;
            return;
          }
        }
        
        // Show debug button for administrators
        if (isOwner) {
          document.getElementById('debugButton').style.display = 'inline-block';
        }
        
        // Check if user is whitelisted and not in cooldown
        if (userAddress) {
          const isWhitelisted = await contract.whitelist(userAddress);
          if (isWhitelisted) {
            // Check voting cooldown
            const lastVoteTime = await contract.getLastVoteTime(userAddress);
            const currentTime = Math.floor(Date.now() / 1000); // Current time in seconds
            const sevenDays = 7 * 24 * 60 * 60; // 7 days in seconds
            
            const canVoteNow = lastVoteTime.toString() === "0" || 
                              currentTime >= parseInt(lastVoteTime.toString()) + sevenDays;
            
            voteButton.disabled = !canVoteNow || voteOptionSelect.value === "";
            
            if (!canVoteNow) {
              const nextVoteTime = new Date((parseInt(lastVoteTime.toString()) + sevenDays) * 1000);
              activeProposal.innerHTML += `<p class="cooldown">You can vote again after: ${nextVoteTime.toLocaleString()}</p>`;
            }
          } else {
            voteButton.disabled = true;
            activeProposal.innerHTML += "<p>You are not whitelisted to vote. Please contact your instructor.</p>";
          }
        }
        
        statusElement.innerText = "Active proposal loaded successfully";
      } catch (error) {
        console.error("Error checking active proposal:", error);
        activeProposal.innerHTML = `<p>Error checking active proposal: ${error.message}</p>`;
        voteOptionsContainer.style.display = "none";
        statusElement.innerText = "Error loading active proposal";
      }
    }
    
    // Add helper function to update vote options based on proposal description
    function updateVoteOptions(description) {
      // Clear all existing options
      voteOptionSelect.innerHTML = "";
      
      // Add the default "Select an option" choice
      const defaultOption = document.createElement('option');
      defaultOption.value = "";
      defaultOption.textContent = "Select an option";
      voteOptionSelect.appendChild(defaultOption);
      
      console.log("Parsing options from description:", description);
      
      // Try multiple regex patterns to find numbers that could be options
      let optionNumbers = [];
      
      // First try to find patterns like "1 2 or 3", "1, 2, or 3", etc.
      const matchWithSeparators = description;
      optionNumbers = description.match(/\d+/g);

      // If we found options in the text
      if (optionNumbers && optionNumbers.length > 0) {
        // For the specific contract we're working with, options should be 0-based
        // But we need to check if they're already 0-based or 1-based in the description
        
        // Add each found option
        for (const num of optionNumbers) {
          // We'll keep the displayed values as 1, 2, 3 for user-friendliness
          const optionValue = parseInt(num);
          
          const option = document.createElement('option');
          option.value = optionValue.toString();
          option.textContent = `Option ${optionValue}`;
          voteOptionSelect.appendChild(option);
          
          console.log(`Added option: value=${option.value}, text=${option.textContent}`);
        }
      } else {
        // If no options were found in the description, use default options 1-3
        console.log("No options found in description, using defaults");
        for (let i = 1; i <= 3; i++) {
          const option = document.createElement('option');
          option.value = i.toString();
          option.textContent = `Option ${i}`;
          voteOptionSelect.appendChild(option);
        }
      }
      
      console.log("Final vote options:", Array.from(voteOptionSelect.options).map(o => ({value: o.value, text: o.textContent})));
    }
    
    // Enable/disable vote button based on option selection
    voteOptionSelect.addEventListener('change', function() {
      voteButton.disabled = voteOptionSelect.value === "";
    });
    
    // Submit a new proposal (owner only)
    async function submitProposal() {
      if (!isOwner) {
        alert("Only the instructor can submit proposals");
        return;
      }
      
      const description = proposalDescription.value.trim();
      if (!description) {
        alert("Please enter a proposal description");
        return;
      }
      
      try {
        statusElement.innerText = "Submitting proposal...";
        const tx = await contract.submitProposal(description);
        await tx.wait();
        statusElement.innerText = "Proposal submitted successfully!";
        proposalDescription.value = "";
        
        // Reload proposals
        await loadProposals();
      } catch (error) {
        console.error("Error submitting proposal:", error);
        statusElement.innerText = "Error submitting proposal: " + error.message;
      }
    }
    
    // Start voting on a proposal (owner only)
    async function startVoting() {
      if (!isOwner) {
        alert("Only the instructor can start voting");
        return;
      }
      
      const proposalId = proposalSelector.value;
      if (!proposalId) {
        alert("Please select a proposal");
        return;
      }
      
      try {
        statusElement.innerText = "Starting voting...";
        const tx = await contract.startVoting(proposalId);
        await tx.wait();
        statusElement.innerText = "Voting started successfully!";
        
        // Reload proposals
        await loadProposals();
      } catch (error) {
        console.error("Error starting voting:", error);
        statusElement.innerText = "Error starting voting: " + error.message;
      }
    }
    
    // Stop voting (owner only)
    async function stopVoting() {
      if (!isOwner) {
        alert("Only the instructor can stop voting");
        return;
      }
      
      try {
        statusElement.innerText = "Stopping voting...";
        const tx = await contract.stopVoting();
        await tx.wait();
        statusElement.innerText = "Voting stopped successfully!";
        
        // Reload proposals
        await loadProposals();
      } catch (error) {
        console.error("Error stopping voting:", error);
        statusElement.innerText = "Error stopping voting: " + error.message;
      }
    }
    
    // Add a single voter (owner only)
    async function addVoter() {
      if (!isOwner) {
        alert("Only the instructor can add voters");
        return;
      }
      
      const address = voterAddress.value.trim();
      if (!address || !ethers.isAddress(address)) {
        alert("Please enter a valid Ethereum address");
        return;
      }
      
      try {
        statusElement.innerText = "Adding voter...";
        const tx = await contract.addVoter(address);
        await tx.wait();
        statusElement.innerText = "Voter added successfully!";
        voterAddress.value = "";
      } catch (error) {
        console.error("Error adding voter:", error);
        statusElement.innerText = "Error adding voter: " + error.message;
      }
    }
    
    // Add multiple voters (owner only)
    async function addMultipleVoters() {
      if (!isOwner) {
        alert("Only the instructor can add voters");
        return;
      }
      
      const addresses = multipleVoters.value.trim().split('\n');
      const validAddresses = [];
      
      for (const address of addresses) {
        const trimmedAddress = address.trim();
        if (trimmedAddress && ethers.isAddress(trimmedAddress)) {
          validAddresses.push(trimmedAddress);
        }
      }
      
      if (validAddresses.length === 0) {
        alert("Please enter at least one valid Ethereum address");
        return;
      }
      
      if (validAddresses.length > 30) {
        alert("You can only add up to 30 addresses at once");
        return;
      }
      
      // Pad array to 30 elements with zero address if needed
      while (validAddresses.length < 30) {
        validAddresses.push("0x0000000000000000000000000000000000000000");
      }
      
      try {
        statusElement.innerText = "Adding voters...";
        const tx = await contract.addVoters(validAddresses);
        await tx.wait();
        statusElement.innerText = `${validAddresses.length} voters added successfully!`;
        multipleVoters.value = "";
      } catch (error) {
        console.error("Error adding voters:", error);
        statusElement.innerText = "Error adding voters: " + error.message;
      }
    }
    
    // Vote on active proposal
    async function vote() {
      if (!contract) {
        alert("Please connect your wallet first");
        return;
      }
      
      const selectedOption = voteOptionSelect.value;
      if (!selectedOption) {
        alert("Please select an option to vote for");
        return;
      }
      
      try {
        // Check if user is whitelisted
        const isWhitelisted = await contract.whitelist(userAddress);
        if (!isWhitelisted) {
          alert("You are not whitelisted to vote");
          return;
        }
        
        // Check cooldown period
        const lastVoteTime = await contract.getLastVoteTime(userAddress);
        const currentTime = Math.floor(Date.now() / 1000); // Current time in seconds
        const sevenDays = 7 * 24 * 60 * 60; // 7 days in seconds
        
        if (lastVoteTime.toString() !== "0" && currentTime < parseInt(lastVoteTime.toString()) + sevenDays) {
          const nextVoteTime = new Date((parseInt(lastVoteTime.toString()) + sevenDays) * 1000);
          alert(`You can only vote once every 7 days. You can vote again after: ${nextVoteTime.toLocaleString()}`);
          return;
        }
        
        // Parse the selected option value and send directly to the contract
        const optionValue = parseInt(selectedOption);
        
        console.log(`Voting for option ${optionValue} (sending directly to contract)`);
        
        statusElement.innerText = "Submitting vote...";
        const tx = await contract.vote(optionValue);
        await tx.wait();
        statusElement.innerText = `Vote submitted successfully for Option ${optionValue}!`;
        
        // Get the active proposal ID to show the results button
        const activeId = await contract.activeProposalId();
        
        // Show the view results button after successful vote
        const viewResultsBtn = document.getElementById(`view-results-${activeId}`);
        if (viewResultsBtn) {
          viewResultsBtn.style.display = 'inline-block';
        }
        
        // Clear selection
        voteOptionSelect.value = "";
        voteButton.disabled = true;
        
        // Reload active proposal
        await checkActiveProposal();
        await loadProposals();
      } catch (error) {
        console.error("Error voting:", error);
        statusElement.innerText = "Error voting: " + error.message;
      }
    }
    
    // Add a test button for debugging
    const debugButton = document.createElement('button');
    debugButton.id = 'debugButton';
    debugButton.textContent = 'Debug Contract Call';
    debugButton.style.backgroundColor = '#ff9800';
    debugButton.style.display = 'none'; // Hidden by default
    document.querySelector('.section:first-of-type').appendChild(debugButton);
    debugButton.addEventListener('click', testGetActiveProposal);

    // Function to test getActiveProposal directly
    async function testGetActiveProposal() {
      try {
        statusElement.innerText = "Testing getActiveProposal directly...";
        
        // Get the active proposal ID first
        const activeId = await contract.activeProposalId();
        console.log("Active proposal ID:", activeId.toString());
        
        // Check if we have any proposals
        const proposalCount = await contract.proposalCount();
        console.log("Total proposal count:", proposalCount.toString());
        
        if (proposalCount.toString() === "0") {
          statusElement.innerText = "No proposals exist yet";
          return;
        }
        
        // Even if activeId is 0, we'll test it as a valid proposal
        console.log(`Testing proposal #${activeId.toString()} to see if it's active...`);
        
        // Try both methods of getting the proposal
        // Method 1: Call getActiveProposal
        console.log("Method 1: Calling getActiveProposal directly...");
        let rawResult, decodedResult;
        try {
          rawResult = await contract.getActiveProposal();
          console.log("Raw getActiveProposal result:", rawResult);
          decodedResult = decodeActiveProposal(rawResult);
          console.log("Decoded active proposal:", decodedResult);
        } catch (method1Error) {
          console.error("Method 1 failed:", method1Error);
        }
        
        // Method 2: Get the proposal directly
        console.log("Method 2: Getting proposal directly...");
        let directProposal, directResult;
        try {
          directProposal = await contract.proposals(activeId);
          console.log("Direct proposal result:", directProposal);
          
          // Decode the direct proposal
          if (Array.isArray(directProposal)) {
            directResult = {
              description: directProposal[0],
              votes: Array.isArray(directProposal[1]) ? 
                directProposal[1].map(v => typeof v === 'object' ? v.toString() : v) : [],
              isActive: !!directProposal[2]
            };
          } else if (directProposal.description !== undefined) {
            directResult = {
              description: directProposal.description,
              votes: Array.isArray(directProposal.votes) ? 
                directProposal.votes.map(v => typeof v === 'object' ? v.toString() : v) : [],
              isActive: !!directProposal.active
            };
          } else {
            directResult = {
              description: directProposal[0] || "",
              votes: Array.isArray(directProposal[1]) ? 
                directProposal[1].map(v => typeof v === 'object' ? v.toString() : v) : [],
              isActive: !!directProposal[2]
            };
          }
          console.log("Decoded direct proposal:", directResult);
        } catch (method2Error) {
          console.error("Method 2 failed:", method2Error);
        }
        
        // Show the results in the UI for debugging
        const debugInfo = document.createElement('div');
        debugInfo.id = 'debugInfo';
        debugInfo.style.backgroundColor = '#f8f8f8';
        debugInfo.style.border = '1px solid #ddd';
        debugInfo.style.padding = '10px';
        debugInfo.style.marginTop = '20px';
        debugInfo.style.whiteSpace = 'pre-wrap';
        debugInfo.style.fontFamily = 'monospace';
        
        const method1Html = rawResult ? 
          `<p><strong>Raw result type:</strong> ${typeof rawResult}</p>
           <p><strong>Description:</strong> ${decodedResult.description}</p>
           <p><strong>Is Active:</strong> ${decodedResult.isActive}</p>
           <p><strong>Votes:</strong> ${JSON.stringify(decodedResult.votes)}</p>` 
          : '<p>Method failed - see console for details</p>';
          
        const method2Html = directProposal ? 
          `<p><strong>Raw result type:</strong> ${typeof directProposal}</p>
           <p><strong>Description:</strong> ${directResult.description}</p>
           <p><strong>Is Active:</strong> ${directResult.isActive}</p>
           <p><strong>Votes:</strong> ${JSON.stringify(directResult.votes)}</p>` 
          : '<p>Method failed - see console for details</p>';
          
        const recommendation = directProposal && directResult.isActive
          ? 'This proposal is active and should be displayed' 
          : 'This proposal does not appear to be active';
        
        debugInfo.innerHTML = `
          <h3>Debug Info: Proposal #${activeId.toString()}</h3>
          <p><strong>Proposal Count:</strong> ${proposalCount.toString()}</p>
          
          <h4>Method 1: getActiveProposal()</h4>
          ${method1Html}
          
          <h4>Method 2: proposals(${activeId.toString()})</h4>
          ${method2Html}
          
          <h4>Recommendation</h4>
          <p>${recommendation}</p>
        `;
        
        // Add or replace debug info
        const existingDebug = document.getElementById('debugInfo');
        if (existingDebug) {
          existingDebug.parentNode.replaceChild(debugInfo, existingDebug);
        } else {
          document.querySelector('.container').appendChild(debugInfo);
        }
        
        statusElement.innerText = "Debug test complete. Check console for details.";
      } catch (error) {
        console.error("Error testing getActiveProposal:", error);
        statusElement.innerText = "Error testing getActiveProposal: " + error.message;
      }
    }

    // Helper function to decode the active proposal data consistently
    function decodeActiveProposal(rawResult) {
      try {
        console.log("Decoding proposal data:", rawResult);
        
        // Default values
        let description = "";
        let votes = [];
        let isActive = false;
        
        // Handle different return formats
        if (Array.isArray(rawResult)) {
          // Format: [description, votes, isActive]
          description = rawResult[0];
          votes = Array.isArray(rawResult[1]) ? 
            rawResult[1].map(v => typeof v === 'object' ? v.toString() : v) : 
            [];
          isActive = !!rawResult[2]; // Convert to boolean
        } else if (typeof rawResult === 'object') {
          // Handle object format (ethers v6 sometimes returns structs as objects)
          if (rawResult.description !== undefined) {
            description = rawResult.description;
            votes = Array.isArray(rawResult.votes) ? 
              rawResult.votes.map(v => typeof v === 'object' ? v.toString() : v) : 
              [];
            isActive = !!rawResult.active;
          } else {
            // Try to access by numeric index (tuple format)
            description = rawResult[0] || "";
            votes = Array.isArray(rawResult[1]) ? 
              rawResult[1].map(v => typeof v === 'object' ? v.toString() : v) : 
              [];
            isActive = !!rawResult[2];
          }
        } else {
          console.error("Unexpected result format:", rawResult);
        }
        
        return {
          description,
          votes,
          isActive
        };
      } catch (decodeError) {
        console.error("Error decoding proposal data:", decodeError);
        return {
          description: "Error decoding data",
          votes: [],
          isActive: false
        };
      }
    }
    
    // Initialize the application
    init();
  </script>
</body>
</html>